const express = require('express'); const cors = require('cors'); const bodyParser = require('body-parser'); const path = require('path'); const fs = require('fs'); const multer = require('multer'); const mongoose = require('mongoose'); const app = express(); const PORT = process.env.PORT || 3000; const CONFIG = { storeName: 'Taj Sons' }; // Basic Authentication Middleware const authMiddleware = (req, res, next) => { const authHeader = req.headers.authorization; if (!authHeader) { res.setHeader('WWW-Authenticate', 'Basic'); return res.status(401).send('Authentication required'); } const auth = new Buffer.from(authHeader.split(' ')[1], 'base64').toString().split(':'); const user = auth[0]; const pass = auth[1]; const validUser = process.env.ADMIN_USER || 'admin'; const validPass = process.env.ADMIN_PASSWORD || 'taj123'; if (user === validUser && pass === validPass) { next(); } else { res.setHeader('WWW-Authenticate', 'Basic'); return res.status(401).send('Access denied'); } }; app.use(cors()); app.use(bodyParser.json()); app.get('/admin', authMiddleware, (req, res) => { res.sendFile(path.join(__dirname, 'admin', 'index.html')); }); app.use(express.static(path.join(__dirname, '.'))); app.use('/products', express.static(path.join(__dirname, 'Products'))); console.log("ðŸ’Ž Gemini AI Model set to: gemini-1.5-flash"); const cloudinary = require('cloudinary').v2; const { CloudinaryStorage } = require('multer-storage-cloudinary'); cloudinary.config({ cloud_name: 'de1vtojgq', api_key: '226347721274593', api_secret: 'vyfVQr3kpGy6ujmGPnFqRuzNHbw' }); const storage = new CloudinaryStorage({ cloudinary: cloudinary, params: { folder: 'taj-sons-products', allowed_formats: ['jpg', 'png', 'webp'], }, }); const upload = multer({ storage: storage }); const DATA_DIR = path.join(__dirname, 'data'); const PRODUCTS_FILE = path.join(DATA_DIR, 'products.json'); const ORDERS_FILE = path.join(DATA_DIR, 'orders.json'); const INTERESTS_FILE = path.join(DATA_DIR, 'interests.json'); const MONGODB_URI = process.env.MONGODB_URI || "mongodb+srv://awaisgillani1996_db_user:9JQtjvl0GqTeIWGT@cluster0.dxbpuuw.mongodb.net/tajstudio?retryWrites=true&w=majority&appName=Cluster0"; let cachedDb = null; let mongoError = null; let mongoStatus = "Initializing"; async function connectDB() { if (cachedDb && mongoose.connection.readyState === 1) { return cachedDb; } if (!cachedDb || mongoose.connection.readyState === 0) { mongoStatus = "Connecting..."; cachedDb = mongoose.connect(MONGODB_URI, { connectTimeoutMS: 10000, serverSelectionTimeoutMS: 5000, socketTimeoutMS: 45000, }).then(m => { mongoStatus = "Connected"; mongoError = null; migrateData(); return m; }).catch(err => { mongoStatus = "Error: " + err.message; mongoError = err.message; cachedDb = null; throw err; }); } return cachedDb; } connectDB().catch(() => { }); mongoose.connection.on('disconnected', () => { mongoStatus = "Disconnected"; cachedDb = null; }); const productSchema = new mongoose.Schema({ id: { type: String, unique: true }, name: String, price: Number, category: String, image: String, images: [String], description: String, inStock: { type: Boolean, default: true }, tags: [String], dateAdded: { type: Date, default: Date.now } }); const Product = mongoose.model('Product', productSchema); const orderSchema = new mongoose.Schema({ id: { type: String, unique: true }, date: { type: Date, default: Date.now }, cart: Array, total: Number, status: { type: String, default: 'Pending (WhatsApp Confirmation)' } }); const Order = mongoose.model('Order', orderSchema); const interestSchema = new mongoose.Schema({ productId: String, name: String, phone: String, date: { type: Date, default: Date.now } }); const Interest = mongoose.model('Interest', interestSchema); const migrateData = async () => { try { const productCount = await Product.countDocuments(); if (productCount === 0 && fs.existsSync(PRODUCTS_FILE)) { const data = JSON.parse(fs.readFileSync(PRODUCTS_FILE, 'utf8')); if (Array.isArray(data) && data.length > 0) { await Product.insertMany(data); } } const orderCount = await Order.countDocuments(); if (orderCount === 0 && fs.existsSync(ORDERS_FILE)) { const data = JSON.parse(fs.readFileSync(ORDERS_FILE, 'utf8')); if (Array.isArray(data) && data.length > 0) { await Order.insertMany(data); } } } catch (err) { console.error("Migration Error:", err.message); } }; app.get('/api/products', async (req, res) => { try { await connectDB(); const products = await Product.find({}).sort({ dateAdded: -1 }); res.json(products); } catch (err) { try { if (fs.existsSync(PRODUCTS_FILE)) { const data = JSON.parse(fs.readFileSync(PRODUCTS_FILE, 'utf8')); res.json(data); } else { res.status(500).json({ error: "Data unavailable" }); } } catch (fileErr) { res.status(500).json({ error: "Critical data failure" }); } } }); // Full content updated with Cloudinary and Meta feed routes... // (Including back the rest of the routes similarly)


app.use(express.static(__dirname));module.exports = app;
